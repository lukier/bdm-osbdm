bdmctrl utility
===============

Josef Wolf <jw@raven.inka.de> 2003-10-26

The intention of the bdmctrl utility is to do basic control of the target
over the BDM interface. It can be used for various tasks. Examples are
loading code to the target and executing it or do hardware tests. I have
even used it to do rudimentary debugging (as I could still not get the
gdb-patches from the m68k branch to work).

Bdmctrl is invoked like this:

  bdmctrl [options] <device> [<command> [arguments [...]]]
    where options are one ore more of:
      -d <level> (default=0) Choose driver debug level.
      -v <level> (default=1) Choose verbosity level.
      -D <delay> (default=0) Delay count for BDM clock generation.
      -f                     turn warnings into fatal errors

If a command is specified, it is executed. Otherwise commands are read from
stdin. The most common way of invocations is to give the "source" command on
the command line (see below). So a typical invocation would be like this:

  bdmctrl /dev/bdmicd0 source /foo/bar/baz myfirmware.coff

or like this:

  echo source /foo/bar/baz myfirmware.coff | bdmctrl /dev/bdmicd0

The two examples above are semantically almost identical. Please check the
discussion about stdin in the description to the source command for the
exception.

For example, the bundeled test script can be executed with

  bdmctrl /dev/bdmicd0 source m68332.test /path/to/my/executable.coff

This script will do some basic hardware check, load the named executable
into the target and execute it.

The bdmctrl utility shouldn't contain any target specific code and should
therefore work on coldfire as well as on the variuos cpu32 based CPUs.
Currently, it is tested only on 68332 target. Please test it on your target
and report the results so that either the problem can be fixed or the list
of working targets can be extended.


Basic syntax of the commands
============================

A command line is split by whitespace into the command and its arguments in
a similar way like bourne shell does. the '#' character starts a comment.
No quoting is supported. After the split, variable substitution (see the
"source" command) is done.

Register names are prefixed by a '%' (for example %sp) and can be in mixed
case. The '%' can be omitted in most cases, but this is not recommended.

Some commands accept a <value>. If <value> begins with a digit, it will be
parsed as a number. If it begins with a '%', it will be parsed as a register
name. Otherwise it is assumed to be a symbol and its value will be looked
up in the open symbol files.


Supported commands and their parameters
=======================================

reset
  reset the target.

sleep <seconds>
  sleep for <seconds>.

wait
  wait until target is halted/stopped.

patterns <number> [ <number> ... ]
patterns random <count>
  In the first form, the provided numbers are taken as test patterns. In the
  second form <count> random patterns are generated. On startup, bdmctrl
  generates 37 random testpatterns. The patterns are 32 bits wide.
  In general, a prime number of random patterns is best to _detect_ errors.
  Once an error is detected, you might want to define your own patterns in
  order to locate/isolate/understand the problem.

check-register <register> [ <register> ... ]
  The specified registers are checked with random testpatterns. After the
  test, the original values of the registers are restored.

dump-register <register> [ <register> ... ]
  The contents of the specified registers are dumped to stdout.

check-mem <address> <size>
  The specified memory region is checked with a random testpattern. In
  addition, an alingnment test is done. After the test the original memory
  contents are restored.
  <address> and <size> can be a number, a register or a symbol.

dump-mem <address> <size> <width>
  Dump memory contents to stdout. The <width> argument speciefies whether
  bytes, words or longwords are dumped.
  <address> and <size> can be a number, a register or a symbol.
  <width> can be '1', 'b', 'B', '2', 'w', 'W', '4', 'l' or 'L'.

write <destination> <value> <width>
  Write a <value> with <width> to <destination>. <value> and <destination>
  can be an absolute memory address, a register or a symbol.
  <destination> and <value> can be a number, a register or a symbol.
  <width> can be '1', 'b', 'B', '2', 'w', 'W', '4', 'l' or 'L'.

load [-v] <object-file> [ <section> ... ]
  Load <object-file> into the target. Only the specified sections are loaded.
  When no sections are specified, only sections with the LOAD flag are
  loaded. If <object-file> has an entry address specified, %rpc is set to
  this address. With the -v flag, the written contents are read back and
  verified.
  After the load, the symbols from the loaded file are known to the commands
  which can deal with symbols.

execute [<address>]
  Run the target at <address>. If <address> is omitted, the target will run
  from %rpc. In this case you probably want to make sure that you have
  loaded a file with an entry address definition.
  <address> can be a number, a register or a symbol.

source [ <file> [ <arguments> ... ] ]
  Execute commands from <file>. Withhin <file>, the variables $1, $2, $3 (and
  so on) are replaced by the specified arguments. When all the commands from
  <file> are executed, control returns to the original position, so recursive
  execution is possible. When <file> is omitted, commands are read from
  stdin. Please note that it doesn't make much sense to source stdin more
  than one time.


Plans for the future
====================

short time
----------
 - Fix the issues marked with "FIXME"

 - Cleanup/extend output to make it easier to analyze hardware defects.

 - Extend the "execute" command to pass arguments to the target function.
   The big question for this extension is: where to allocate the memory
   for the stack that is needed to put the arguments (and the bgnd
   instruction)
   This extension is a prerequisite for the "flash" command. 

 - Implement a "step" command.

 - Implement variables. Currently, I don't see any use cases for this. OTOH,
   it seems not very hard to do.

long run
--------
 - Implement a "flash" command. This command will use code on the target
   to erase/write the flash.

 - Rewrite parsing to flex/bison. (This one will probably never be done)

 - implement flow control (if/while/for) (This one will probably never be
   done)


Miscelaneus
===========

Bugfixes, bugreports, improvements, suggestions and opinions (in this
order ;-) are welcome.

