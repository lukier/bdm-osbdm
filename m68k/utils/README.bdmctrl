bdmctrl utility
===============

Josef Wolf <jw@raven.inka.de> 2003-10-26

The intention of the bdmctrl utility is to do basic control of the target
over the BDM interface. It can be used for various tasks. Examples are
loading code to the target and executing it or do hardware tests. I have
even used it to do rudimentary debugging (as I could still not get the
gdb-patches from the m68k branch to work).

Bdmctrl is invoked like this:

  bdmctrl [options] <device> [<command> [arguments [...]]]
    where options are one ore more of:
      -d <level> (default=0) Choose driver debug level.
      -v <level> (default=1) Choose verbosity level.
      -D <delay> (default=0) Delay count for BDM clock generation.
      -f                     turn warnings into fatal errors

If a command is specified, it is executed. Otherwise commands are read from
stdin. The most common way of invocations is to give the "source" command on
the command line (see below). So a typical invocation would be like this:

  bdmctrl /dev/bdmicd0 source /foo/bar/baz myfirmware.coff

or like this:

  echo source /foo/bar/baz myfirmware.coff | bdmctrl /dev/bdmicd0

The two examples above are semantically almost identical. Please check the
discussion about stdin in the description to the source command for the
exception.

For example, the bundeled test script can be executed with

  bdmctrl /dev/bdmicd0 source m68332.test /path/to/my/executable.coff

This script will do some basic hardware check, load the named executable
into the target and execute it.

The bdmctrl utility shouldn't contain any target specific code and should
therefore work on coldfire as well as on the variuos cpu32 based CPUs.
Currently, it is tested only on 68332 target. Please test it on your target
and report the results so that either the problem can be fixed or the list
of working targets can be extended.


Basic syntax of the commands
============================

A command line is split by whitespace into the command and its arguments in
a similar way like bourne shell does. the '#' character starts a comment.
No quoting is supported. After the split, variable substitution (see the
"source" command) is done.

Register names are prefixed by a '%' (for example %sp) and can be in mixed
case. The '%' can be omitted in most cases, but this is not recommended.

Some commands accept a <value>. If <value> begins with a digit, it will be
parsed as a number. If it begins with a '%', it will be parsed as a register
name. Otherwise it is assumed to be a symbol and its value will be looked
up in the open symbol files.


Supported commands and their parameters
=======================================

reset
  reset the target.

time
  print seconds since bdmctrl was started.

exit
  exit bdmctrl immediately.

sleep <seconds>
  sleep for <seconds>.

echo [ <arguments> ... ]
  print a line of text.

set <name> <value>
  define variable <name> and set its value to <value>

read [ <var> ... ]
  read a line from stdin, split it into arguments and assign the arguments
  to specified variables.

wait
  wait until target is halted/stopped.

patterns <number> [ <number> ... ]
patterns random <count>
  In the first form, the provided numbers are taken as test patterns. In the
  second form <count> random patterns are generated. On startup, bdmctrl
  generates 37 random testpatterns. The patterns are 32 bits wide.
  In general, a prime number of random patterns is best to _detect_ errors.
  Once an error is detected, you might want to define your own patterns in
  order to locate/isolate/understand the problem.

check-register <register> [ <register> ... ]
  The specified registers are checked with random testpatterns. After the
  test, the original values of the registers are restored.

dump-register <register> [ <register> ... ]
  The contents of the specified registers are dumped to stdout.

check-mem <address> <size>
  The specified memory region is checked with a random testpattern. In
  addition, an alingnment test is done. After the test the original memory
  contents are restored.
  <address> and <size> can be a number, a register or a symbol.

dump-mem <address> <size> <width> [<filename>]
  Dump memory contents to stdout. The <width> argument speciefies whether
  bytes, words or longwords are dumped.
  <address> and <size> can be a number, a register or a symbol.
  <width> can be '1', 'b', 'B', '2', 'w', 'W', '4', 'l' or 'L'.
  if <filename> is specified, the contents are dumped to the named file.

write <destination> <value> <width>
  Write a <value> with <width> to <destination>. <value> and <destination>
  can be an absolute memory address, a register or a symbol.
  <destination> and <value> can be a number, a register or a symbol.
  <width> can be '1', 'b', 'B', '2', 'w', 'W', '4', 'l' or 'L'.

load [-v] <object-file> [ <section> ... ]
  Load <object-file> into the target. Only the specified sections are loaded.
  When no sections are specified, only sections with the LOAD flag are
  loaded. If <object-file> has an entry address specified, %rpc is set to
  this address. With the -v flag, the written contents are read back and
  verified.
  After the load, the symbols from the loaded file are known to the commands
  which can deal with symbols.
  Please note that s-record and intel-hex don't have section names. In this
  cases BFD assigns ".sec1", ".sec2" and so forth as section names.

execute [<address>]
  Run the target at <address>. If <address> is omitted, the target will run
  from %rpc. In this case you probably want to make sure that you have
  loaded a file with an entry address definition.
  <address> can be a number, a register or a symbol.

step [<address>]
  Step the target at <address>. If <address> is omitted, the target will
  step on %rpc. In this case you probably want to make sure that you have
  loaded a file with an entry address definition.
  <address> can be a number, a register or a symbol.

source [ <file> [ <arguments> ... ] ]
  Execute commands from <file>. Withhin <file>, the variables $1, $2, $3 (and
  so on) are replaced by the specified arguments. When all the commands from
  <file> are executed, control returns to the original position, so recursive
  execution is possible. When <file> is omitted, commands are read from
  stdin. Please note that it doesn't make much sense to source stdin more
  than one time.

flash-plugin <address> <length> <file> [ <file> ... ]
  Load and register a target-assisted flash driver plugin(s) from <file>.
  <address> and <length> define a memory region on the target that can be
  used as temporary memory to download driver and flash contents.

flash <address>
  Autodetect flash chip(s) on <address>. Currently only 29Fxxx and 49Fxxx
  types of chips are supported.
  Note that there is no dedicated command for the actual flash operation. The
  usual memory write command "load" will automatically call the correct driver
  for registered memory areas.

erase <base> <sector_offset>
  Submit erase command to sector with <sector_offset> on flash chip at <base>.
  <sector_offset>==-1 indicates the whole chip. For 29Fxxx and 49Fxxx types of
  chips multiple erase commands can be issued simultanously.

erase <base> wait
  Wait for the flash chip on <base> to finish the issued erase operation(s).


Plans for the future
====================

short time
----------
 - Fix the issues marked with "FIXME"

 - Extend "write" command to automatically call flash driver.

 - Cleanup/extend output to make it easier to analyze hardware defects.

 - Extend the "execute" command to pass arguments to the target function.
   The big question for this extension is: where to allocate the memory
   for the stack that is needed to put the arguments (and the bgnd
   instruction)
   This extension is a prerequisite for the "flash" command. 
   [ Is this remark stilll valid? ]

long run
--------
 - implement breakpoints.

 - implement disassembler.

 - Rewrite parsing to flex/bison. (This one will probably never be done)

 - implement flow control (if/while/for) (This one will probably never be
   done)


Miscelaneus
===========

Bugfixes, bugreports, improvements, suggestions and opinions (in this
order ;-) are welcome.

