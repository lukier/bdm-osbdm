bdmctrl utility
===============

Josef Wolf <jw@raven.inka.de> 2003-10-26

The intention of the bdmctrl utility is to do basic control of the target
over the BDM interface. It can be used for various tasks. Examples are
loading code to the target and executing it or do hardware tests. I have
even used it to do rudimentary debugging (as I could still not get the
gdb-patches from the m68k branch to work).

Bdmctrl is invoked like this:

  bdmctrl [options] <device> [<command> [arguments [...]]]
    where options are one ore more of:
      -h <cmd>   Get additional description for command <cmd>.
      -d <level> (default=0) Choose driver debug level.
      -v <level> (default=1) Choose verbosity level.
      -D <delay> (default=0) Delay count for BDM clock generation.
      -f                     turn warnings into fatal errors

If a command is specified on the command line, bdmctrl executs the command
and exits. If no command is specified on the command line, commands are read
and executed from stdin until EOF is encountered. The most common way of
invocations is to give the "source" command on the command line (see below).
So a typical invocation would be like this:

  bdmctrl /dev/bdmicd0 source /foo/bar/baz myfirmware.coff

or like this:

  echo source /foo/bar/baz myfirmware.coff | bdmctrl /dev/bdmicd0

The two examples above are semantically almost identical. Please check the
discussion about stdin in the description to the "source" command for the
exception.

For example, the bundeled test script can be executed with

  bdmctrl /dev/bdmicd0 source m68332.test /path/to/my/executable.coff

This script will do some basic hardware check, load the named executable
into the target and execute it.

The bdmctrl utility shouldn't contain any target specific code and should
therefore work on coldfire as well as on the variuos cpu32 based CPUs.
Currently, it is tested only on 68332 target. Please test it on your target
and report the results so that either the problem can be fixed or the list
of working targets can be extended.


Basic syntax of the commands
============================

A command line is split by whitespace into the command and its arguments in
a similar way like bourne shell does. the '#' character starts a comment.
No quoting is supported. After the split, variable substitution (see the
"source" command) is done.

Register names are prefixed by a '%' (for example %sp) and can be in mixed
case. The '%' can be omitted in most cases, but this is not recommended.

Some commands accept a VAL. If VAL begins with a digit, it will be
parsed as a number. If it begins with "0x" it is parsed as a hex number.
If it begins with "0" it is parsed as an octal number. If it begins
with "%", it will be parsed as a register name and the contents of the named
register will be taken. Otherwise it is assumed to be a symbol and its value
will be looked up in the open symbol files.


Supported commands and their parameters
=======================================

Please use "bdmctrl -h" to get a list of available commands.
Please use "bdmctrl -h COMMAND" to get information on the command.


Plans for the future
====================

short time
----------
 - Fix the issues marked with "FIXME"

 - Extend "write" command to automatically call flash driver.

 - Cleanup/extend output to make it easier to analyze hardware defects.

 - Extend the "execute" command to pass arguments to the target function.
   The big question for this extension is: where to allocate the memory
   for the stack that is needed to put the arguments (and the bgnd
   instruction)
   This extension is a prerequisite for the "flash" command. 
   [ Is this remark stilll valid? ]

long run
--------
 - implement breakpoints.

 - implement disassembler.

 - Rewrite parsing to flex/bison. (This one will probably never be done)

 - implement flow control (if/while/for) (This one will probably never be
   done)


Miscelaneus
===========

Bugfixes, bugreports, improvements, suggestions and opinions (in this
order ;-) are welcome.

